import 'package:cloud_firestore/cloud_firestore.dart';
// For ProduceListing reference
// For BuyerRequest reference
// import './order.dart'; // Potentially for Order reference

/// Status of a match suggestion between a farmer's produce and a buyer's request.
///
/// Tracks the current approval and confirmation state of a match suggestion
/// as it moves through the lifecycle from initial suggestion to order creation.
enum MatchStatus {
  /// Waiting for the farmer to approve the match suggestion.
  pending_farmer_approval('Pending Farmer Approval'),
  
  /// Waiting for the buyer to approve the match suggestion.
  pending_buyer_approval('Pending Buyer Approval'),
  // pending_both_approval('Pending Both Approvals'), // if parallel approval is allowed
  
  /// Match has been accepted by the farmer, still waiting for buyer approval.
  accepted_by_farmer('Accepted by Farmer'),
  
  /// Match has been accepted by the buyer, still waiting for farmer approval.
  accepted_by_buyer('Accepted by Buyer'),
  
  /// Match has been confirmed by both parties and is ready to become an order.
  confirmed('Confirmed by Both'), // Ready to become an order
  
  /// Match was rejected by the farmer.
  rejected_by_farmer('Rejected by Farmer'),
  
  /// Match was rejected by the buyer.
  rejected_by_buyer('Rejected by Buyer'),
  
  /// Match suggestion expired without being confirmed.
  expired('Expired'), // Suggestion timed out
  
  /// Match suggestion was cancelled (e.g., if listing becomes unavailable).
  cancelled('Cancelled'), // e.g. if listing becomes unavailable
  
  /// An order has been created from this match suggestion.
  order_created('Order Created'),
  
  /// Suggestion generated by AI for buyer consideration.
  ai_suggestion_for_buyer('AI Suggestion'); // Added for AI-generated suggestions

  /// Creates a new [MatchStatus] with the specified display name.
  const MatchStatus(this.displayName);
  
  /// User-friendly name of the status for display purposes.
  final String displayName;
}

/// Represents a suggested match between a farmer's produce listing and a buyer's interest.
///
/// Match suggestions can be created by the system based on AI matching algorithms,
/// or directly from user interactions. They represent potential transactions
/// before they become formal orders, allowing both parties to approve the match.
class MatchSuggestion {
  /// Unique identifier for this match suggestion.
  final String? id;
  
  /// ID of the produce listing being offered.
  final String produceListingId;
  // final ProduceListing? produceListing; // Optional: denormalized full listing, or fetch separately
  
  /// ID of the farmer who owns the produce listing.
  final String farmerId; // Denormalized from ProduceListing for easier querying/rules

  /// ID of the buyer request that this match fulfills (null for direct matches).
  final String? buyerRequestId; // Null if it's a direct match from buyer interest not a formal request
  // final BuyerRequest? buyerRequest; // Optional: denormalized full request
  
  /// ID of the buyer who showed interest or made the request.
  final String buyerId; // Who showed interest or made the request

  // ADDED: Denormalized fields for easier display
  /// Name of the produce being matched (denormalized for display).
  final String produceName;
  
  /// Name of the farmer offering the produce (denormalized for display).
  final String? farmerName;
  
  /// Name of the buyer requesting/interested in the produce (denormalized for display).
  final String? buyerName;

  /// Quantity of produce suggested for this match.
  final double suggestedQuantity;
  
  /// Unit of measurement for the quantity (e.g., "kg", "piece").
  final String unit; // Should match produceListing.unit
  
  /// Price per unit suggested for this match.
  final double? suggestedPricePerUnit; // Can be from listing, or negotiated, or from buyer request range
  
  /// Currency for the suggested price.
  final String? currency; // Should match

  // AI/System generated fields
  /// AI-computed match score between 0.0 and 1.0 indicating match quality.
  final double aiMatchScore; // 0.0 to 1.0
  
  /// Brief explanation of why this match was suggested by the AI.
  final String aiMatchRationale; // Brief explanation
  
  /// Additional system-generated notes about this match.
  final String? systemNotes; // e.g., "Prioritized due to nearing expiry"

  /// Current status of this match suggestion.
  final MatchStatus status;
  
  /// Reason provided if the farmer rejected this match.
  final String? farmerRejectionReason;
  
  /// Reason provided if the buyer rejected this match.
  final String? buyerRejectionReason;

  /// When this match suggestion was created.
  final DateTime createdAt;
  
  /// When this match suggestion was last updated.
  final DateTime lastUpdated;
  
  /// When this match suggestion expires if not confirmed.
  final DateTime? expiresAt; // When this suggestion is no longer valid

  /// ID of the order created from this match, if one was created.
  final String? createdOrderId; // ID of the Order created from this match

  /// Creates a new [MatchSuggestion].
  ///
  /// The [produceListingId], [farmerId], [buyerId], [produceName], [suggestedQuantity],
  /// [unit], [aiMatchScore], [aiMatchRationale], [status], [createdAt], and [lastUpdated]
  /// parameters are required.
  MatchSuggestion({
    this.id,
    required this.produceListingId,
    required this.farmerId,
    this.buyerRequestId,
    required this.buyerId,
    // ADDED: New fields in constructor
    required this.produceName,
    this.farmerName,
    this.buyerName,
    required this.suggestedQuantity,
    required this.unit,
    this.suggestedPricePerUnit,
    this.currency,
    required this.aiMatchScore,
    required this.aiMatchRationale,
    this.systemNotes,
    required this.status,
    this.farmerRejectionReason,
    this.buyerRejectionReason,
    required this.createdAt,
    required this.lastUpdated,
    this.expiresAt,
    this.createdOrderId,
    // this.produceListing, // Removed to avoid circular dependency if full obj is embedded
    // this.buyerRequest,
  });

  /// Creates a [MatchSuggestion] from Firestore document data.
  ///
  /// The [data] parameter contains document data and [id] is the document ID.
  ///
  /// Returns a [MatchSuggestion] instance populated with data from Firestore.
  factory MatchSuggestion.fromFirestore(Map<String, dynamic> data, String id) {
    return MatchSuggestion(
      id: id,
      produceListingId: data['produceListingId'] as String,
      farmerId: data['farmerId'] as String,
      buyerRequestId: data['buyerRequestId'] as String?,
      buyerId: data['buyerId'] as String,
      // ADDED: New fields in fromFirestore
      produceName: data['produceName'] as String? ?? 'Unknown Produce', // Provide a fallback
      farmerName: data['farmerName'] as String?,
      buyerName: data['buyerName'] as String?,
      suggestedQuantity: (data['suggestedQuantity'] as num).toDouble(),
      unit: data['unit'] as String,
      suggestedPricePerUnit: (data['suggestedPricePerUnit'] as num?)?.toDouble(),
      currency: data['currency'] as String?,
      aiMatchScore: (data['aiMatchScore'] as num).toDouble(),
      aiMatchRationale: data['aiMatchRationale'] as String,
      systemNotes: data['systemNotes'] as String?,
      status: MatchStatus.values.firstWhere(
        (e) => e.name == data['status'],
        orElse: () => MatchStatus.pending_farmer_approval, // Sensible default
      ),
      farmerRejectionReason: data['farmerRejectionReason'] as String?,
      buyerRejectionReason: data['buyerRejectionReason'] as String?,
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      lastUpdated: (data['lastUpdated'] as Timestamp).toDate(),
      expiresAt: (data['expiresAt'] as Timestamp?)?.toDate(),
      createdOrderId: data['createdOrderId'] as String?,
    );
  }

  /// Converts this match suggestion to a map for Firestore storage.
  ///
  /// Creates a map representation with non-null fields for storing in Firestore.
  ///
  /// Returns a Map containing the match suggestion data ready for Firestore.
  Map<String, dynamic> toFirestore() {
    return {
      'produceListingId': produceListingId,
      'farmerId': farmerId,
      if (buyerRequestId != null) 'buyerRequestId': buyerRequestId,
      'buyerId': buyerId,
      // ADDED: New fields in toFirestore
      'produceName': produceName,
      if (farmerName != null) 'farmerName': farmerName,
      if (buyerName != null) 'buyerName': buyerName,
      'suggestedQuantity': suggestedQuantity,
      'unit': unit,
      if (suggestedPricePerUnit != null) 'suggestedPricePerUnit': suggestedPricePerUnit,
      if (currency != null) 'currency': currency,
      'aiMatchScore': aiMatchScore,
      'aiMatchRationale': aiMatchRationale,
      if (systemNotes != null) 'systemNotes': systemNotes,
      'status': status.name,
      if (farmerRejectionReason != null) 'farmerRejectionReason': farmerRejectionReason,
      if (buyerRejectionReason != null) 'buyerRejectionReason': buyerRejectionReason,
      'createdAt': Timestamp.fromDate(createdAt),
      'lastUpdated': Timestamp.fromDate(lastUpdated),
      if (expiresAt != null) 'expiresAt': Timestamp.fromDate(expiresAt!),
      if (createdOrderId != null) 'createdOrderId': createdOrderId,
    };
  }

  /// Creates a copy of this match suggestion with the specified fields replaced.
  ///
  /// Returns a new [MatchSuggestion] instance with updated fields while preserving
  /// the values of fields that are not specified.
  MatchSuggestion copyWith({
    String? id,
    String? produceListingId,
    String? farmerId,
    String? buyerRequestId,
    String? buyerId,
    // ADDED: New fields in copyWith
    String? produceName,
    String? farmerName,
    String? buyerName,
    double? suggestedQuantity,
    String? unit,
    double? suggestedPricePerUnit,
    String? currency,
    double? aiMatchScore,
    String? aiMatchRationale,
    String? systemNotes,
    MatchStatus? status,
    String? farmerRejectionReason,
    String? buyerRejectionReason,
    DateTime? createdAt,
    DateTime? lastUpdated,
    DateTime? expiresAt,
    String? createdOrderId,
  }) {
    return MatchSuggestion(
      id: id ?? this.id,
      produceListingId: produceListingId ?? this.produceListingId,
      farmerId: farmerId ?? this.farmerId,
      buyerRequestId: buyerRequestId ?? this.buyerRequestId,
      buyerId: buyerId ?? this.buyerId,
      // ADDED: New fields in copyWith
      produceName: produceName ?? this.produceName,
      farmerName: farmerName ?? this.farmerName,
      buyerName: buyerName ?? this.buyerName,
      suggestedQuantity: suggestedQuantity ?? this.suggestedQuantity,
      unit: unit ?? this.unit,
      suggestedPricePerUnit: suggestedPricePerUnit ?? this.suggestedPricePerUnit,
      currency: currency ?? this.currency,
      aiMatchScore: aiMatchScore ?? this.aiMatchScore,
      aiMatchRationale: aiMatchRationale ?? this.aiMatchRationale,
      systemNotes: systemNotes ?? this.systemNotes,
      status: status ?? this.status,
      farmerRejectionReason: farmerRejectionReason ?? this.farmerRejectionReason,
      buyerRejectionReason: buyerRejectionReason ?? this.buyerRejectionReason,
      createdAt: createdAt ?? this.createdAt,
      lastUpdated: lastUpdated ?? this.lastUpdated,
      expiresAt: expiresAt ?? this.expiresAt,
      createdOrderId: createdOrderId ?? this.createdOrderId,
    );
  }
} 